"""
Enhanced vulnerability scanner with severity scoring and CVE support.
"""

import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

class SeverityLevel(Enum):
    """Enumeration for vulnerability severity levels."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

@dataclass
class Vulnerability:
    """Enhanced vulnerability data structure."""
    id: str
    title: str
    severity: SeverityLevel
    severity_score: float
    description: str
    impact: str
    remediation: str
    resource_type: str
    resource_name: str
    attribute: str
    expected_value: Any
    actual_value: Any
    cve_references: List[str]
    cis_controls: List[str]
    tags: List[str]
    references: List[str]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary format."""
        return {
            "id": self.id,
            "title": self.title,
            "severity": self.severity.value,
            "severity_score": self.severity_score,
            "description": self.description,
            "impact": self.impact,
            "remediation": self.remediation,
            "resource": {
                "type": self.resource_type,
                "name": self.resource_name
            },
            "details": {
                "attribute": self.attribute,
                "expected": self.expected_value,
                "actual": self.actual_value
            },
            "references": {
                "cve": self.cve_references,
                "cis_controls": self.cis_controls,
                "documentation": self.references
            },
            "tags": self.tags
        }

class EnhancedVulnerabilityScanner:
    """Enhanced vulnerability scanner with CVE and severity support."""
    
    def __init__(self):
        self.vulnerabilities_found = []
        self.ignored_count = 0
        
    def evaluate_condition(self, resource_data: Dict[str, Any], rule: Dict[str, Any]) -> bool:
        """
        Evaluate rule conditions against resource data.
        Supports simple value matching and complex conditions.
        """
        attribute = rule.get('attribute')
        expected_value = rule.get('value')
        condition = rule.get('condition', 'equals')
        
        if attribute not in resource_data:
            # Handle missing attributes
            if condition == 'missing':
                return True
            return False
        
        actual_value = resource_data[attribute]
        
        # Handle different condition types
        if condition == 'equals' or condition is None:
            return actual_value == expected_value
        elif condition == 'missing':
            return False  # Attribute exists, so not missing
        elif condition == 'contains_cidr_0.0.0.0/0':
            # Special condition for security group rules
            if isinstance(actual_value, list):
                for item in actual_value:
                    if isinstance(item, dict) and '0.0.0.0/0' in str(item.get('cidr_blocks', [])):
                        return True
            return False
        elif condition == 'has_rules':
            # Check if security group has any rules
            if isinstance(actual_value, str) and actual_value == 'default':
                # Check if this default security group has ingress/egress rules
                ingress = resource_data.get('ingress', [])
                egress = resource_data.get('egress', [])
                return len(ingress) > 0 or len(egress) > 0
            return False
        
        return False
    
    def scan_resources(self, plan_data: Dict[str, Any], rules: List[Dict[str, Any]], 
                      ignored_findings: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Scan resources against enhanced security rules.
        
        Args:
            plan_data: Terraform plan JSON data
            rules: List of security rules
            ignored_findings: List of ignored findings
            
        Returns:
            Dictionary containing scan results
        """
        if ignored_findings is None:
            ignored_findings = []
            
        self.vulnerabilities_found = []
        self.ignored_count = 0
        
        resources = plan_data.get('planned_values', {}).get('root_module', {}).get('resources', [])
        
        for rule in rules:
            for resource in resources:
                if resource.get('type') == rule.get('resource'):
                    resource_values = resource.get('values', {})
                    
                    if self.evaluate_condition(resource_values, rule):
                        vulnerability = self._create_vulnerability(rule, resource, resource_values)
                        
                        # Check if this finding should be ignored
                        if self._is_ignored(vulnerability, ignored_findings):
                            self.ignored_count += 1
                        else:
                            self.vulnerabilities_found.append(vulnerability)
        
        return self._generate_scan_report()
    
    def _create_vulnerability(self, rule: Dict[str, Any], resource: Dict[str, Any], 
                            resource_values: Dict[str, Any]) -> Vulnerability:
        """Create a vulnerability object from rule and resource data."""
        return Vulnerability(
            id=rule.get('id', 'UNKNOWN'),
            title=rule.get('title', rule.get('description', 'Unknown vulnerability')),
            severity=SeverityLevel(rule.get('severity', 'MEDIUM')),
            severity_score=float(rule.get('severity_score', 5.0)),
            description=rule.get('description', ''),
            impact=rule.get('impact', 'Unknown impact'),
            remediation=rule.get('remediation', 'No remediation provided'),
            resource_type=resource.get('type', ''),
            resource_name=resource.get('name', ''),
            attribute=rule.get('attribute', ''),
            expected_value=rule.get('value'),
            actual_value=resource_values.get(rule.get('attribute')),
            cve_references=rule.get('cve_references', []),
            cis_controls=rule.get('cis_controls', []),
            tags=rule.get('tags', []),
            references=rule.get('references', [])
        )
    
    def _is_ignored(self, vulnerability: Vulnerability, ignored_findings: List[Dict[str, Any]]) -> bool:
        """Check if a vulnerability should be ignored."""
        for ignored in ignored_findings:
            if ignored.get('resource_name') == vulnerability.resource_name:
                if ignored.get('rule_id', vulnerability.id) == vulnerability.id:
                    return True
        return False
    
    def _generate_scan_report(self) -> Dict[str, Any]:
        """Generate comprehensive scan report."""
        # Sort vulnerabilities by severity score (highest first)
        sorted_vulns = sorted(self.vulnerabilities_found, 
                            key=lambda v: v.severity_score, reverse=True)
        
        # Count by severity
        severity_counts = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0,
            'INFO': 0
        }
        
        total_score = 0.0
        for vuln in sorted_vulns:
            severity_counts[vuln.severity.value] += 1
            total_score += vuln.severity_score
        
        # Calculate risk score (average of all vulnerability scores)
        risk_score = total_score / len(sorted_vulns) if sorted_vulns else 0.0
        
        return {
            'summary': {
                'total_vulnerabilities': len(sorted_vulns),
                'ignored_findings': self.ignored_count,
                'risk_score': round(risk_score, 2),
                'severity_distribution': severity_counts
            },
            'vulnerabilities': [vuln.to_dict() for vuln in sorted_vulns],
            'metadata': {
                'scan_timestamp': None,  # Will be set by caller
                'rules_applied': None,   # Will be set by caller
                'resources_scanned': None  # Will be set by caller
            }
        }
    
    def filter_by_severity(self, min_severity_score: float = 0.0, 
                          severity_levels: List[str] = None) -> List[Vulnerability]:
        """Filter vulnerabilities by severity criteria."""
        filtered = []
        
        for vuln in self.vulnerabilities_found:
            # Filter by score
            if vuln.severity_score < min_severity_score:
                continue
                
            # Filter by severity level
            if severity_levels and vuln.severity.value not in severity_levels:
                continue
                
            filtered.append(vuln)
        
        return filtered
    
    def filter_by_cve(self, cve_id: str) -> List[Vulnerability]:
        """Filter vulnerabilities that reference a specific CVE."""
        return [vuln for vuln in self.vulnerabilities_found 
                if cve_id in vuln.cve_references]
    
    def filter_by_tags(self, tags: List[str]) -> List[Vulnerability]:
        """Filter vulnerabilities by tags."""
        return [vuln for vuln in self.vulnerabilities_found 
                if any(tag in vuln.tags for tag in tags)]