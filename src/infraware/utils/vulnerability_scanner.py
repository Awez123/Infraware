"""
Enhanced vulnerability scanner with severity scoring and CVE support.
"""

import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

# Import our modern CVE database
from .cve_database import CVEDatabase

class SeverityLevel(Enum):
    """Enumeration for vulnerability severity levels."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

@dataclass
class Vulnerability:
    """Enhanced vulnerability data structure."""
    id: str
    title: str
    severity: SeverityLevel
    severity_score: float
    description: str
    impact: str
    remediation: str
    resource_type: str
    resource_name: str
    attribute: str
    expected_value: Any
    actual_value: Any
    cve_references: List[str]
    cis_controls: List[str]
    tags: List[str]
    references: List[str]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary format."""
        return {
            "id": self.id,
            "title": self.title,
            "severity": self.severity.value,
            "severity_score": self.severity_score,
            "description": self.description,
            "impact": self.impact,
            "remediation": self.remediation,
            "resource": {
                "type": self.resource_type,
                "name": self.resource_name
            },
            "details": {
                "attribute": self.attribute,
                "expected": self.expected_value,
                "actual": self.actual_value
            },
            "references": {
                "cve": self.cve_references,
                "cis_controls": self.cis_controls,
                "documentation": self.references
            },
            "tags": self.tags
        }

class EnhancedVulnerabilityScanner:
    """Enhanced vulnerability scanner with CVE and severity support."""
    
    def __init__(self):
        self.vulnerabilities_found = []
        self.ignored_count = 0
        # Initialize CVE database for enhanced scanning
        self.cve_db = CVEDatabase()
        
    def get_related_cves(self, resource_type: str, vulnerability_type: str) -> List[str]:
        """Get related CVEs from our modern database."""
        try:
            # Auto-grow the database
            self.cve_db._check_auto_grow()
            
            # Search for relevant CVEs based on resource type and vulnerability
            search_terms = [
                resource_type.lower().replace('aws_', '').replace('azure_', '').replace('google_', ''),
                vulnerability_type.lower(),
                'infrastructure',
                'cloud'
            ]
            
            related_cves = []
            for term in search_terms[:2]:  # Limit search to avoid too many results
                cves = self.cve_db.search_cves(term, limit=3)
                for cve in cves:
                    if cve.cve_id not in related_cves:
                        related_cves.append(cve.cve_id)
                        
            return related_cves[:5]  # Limit to top 5 most relevant
            
        except Exception as e:
            print(f"⚠️ CVE lookup failed: {e}")
            return []
            
    def enhance_vulnerability_with_cves(self, vulnerability: 'Vulnerability') -> 'Vulnerability':
        """Enhanced vulnerability CVE correlation with infrastructure-specific intelligence."""
        try:
            # Initialize CVE database and trigger auto-growth
            from .cve_database import CVEDatabase
            cve_db = CVEDatabase()
            cve_db._check_auto_grow()  # Use the actual private method name
            
            related_cves = []
            
            # 🎯 MULTI-STRATEGY CVE CORRELATION
            
            # Strategy 1: Technology/Service specific CVEs
            tech_keywords = self._extract_tech_keywords(vulnerability)
            for keyword in tech_keywords:
                cves = cve_db.search_cves(keyword, limit=2)
                related_cves.extend([cve.cve_id for cve in cves])
            
            # Strategy 2: Configuration vulnerability patterns
            config_cves = self._get_config_related_cves(vulnerability, cve_db)
            related_cves.extend(config_cves)
            
            # Strategy 3: Resource-specific known CVEs
            resource_cves = self._get_resource_specific_cves(vulnerability)
            related_cves.extend(resource_cves)
            
            # Remove duplicates and update vulnerability
            unique_cves = list(set(related_cves))[:5]
            if unique_cves:
                vulnerability.cve_references = unique_cves
                
            return vulnerability
            
        except Exception as e:
            print(f"🔍 CVE enhancement skipped: {e}")
            return vulnerability
    
    def _extract_tech_keywords(self, vulnerability: 'Vulnerability') -> List[str]:
        """Extract technology keywords for targeted CVE searching."""
        keywords = []
        
        # Resource type mapping
        resource_type = vulnerability.resource_type.lower()
        title = vulnerability.title.lower()
        
        if 'kubernetes' in resource_type or 'k8s' in title:
            keywords.extend(['kubernetes', 'container', 'docker'])
        elif 'aws_s3' in resource_type:
            keywords.extend(['s3', 'bucket', 'storage'])
        elif 'aws_ec2' in resource_type:
            keywords.extend(['ec2', 'instance', 'virtual machine'])
        elif 'aws_rds' in resource_type:
            keywords.extend(['rds', 'database', 'mysql', 'postgresql'])
        elif 'aws_ebs' in resource_type:
            keywords.extend(['ebs', 'volume', 'storage'])
        elif 'security_group' in resource_type:
            keywords.extend(['firewall', 'security group', 'network'])
        
        # Vulnerability pattern keywords
        if 'encrypt' in title:
            keywords.extend(['encryption', 'unencrypted'])
        if 'public' in title:
            keywords.extend(['exposure', 'public access'])
        if 'privilege' in title:
            keywords.extend(['privilege escalation', 'root'])
        
        return list(set(keywords))
    
    def _get_config_related_cves(self, vulnerability: 'Vulnerability', cve_db) -> List[str]:
        """Get CVEs related to configuration vulnerabilities."""
        config_cves = []
        title = vulnerability.title.lower()
        
        # Map common config issues to known CVE patterns
        if 'encrypt' in title and 's3' in vulnerability.resource_type.lower():
            # S3 encryption related CVEs
            config_cves.extend(['CVE-2023-28867', 'CVE-2022-25169'])
        elif 'public' in title and 's3' in vulnerability.resource_type.lower():
            # S3 public access CVEs
            config_cves.extend(['CVE-2023-33747', 'CVE-2022-40617'])
        elif 'privilege' in title and 'kubernetes' in vulnerability.resource_type.lower():
            # Kubernetes privilege escalation CVEs
            config_cves.extend(['CVE-2024-21626', 'CVE-2023-2728'])
        elif 'security_group' in vulnerability.resource_type.lower():
            # Network security CVEs
            config_cves.extend(['CVE-2023-1829', 'CVE-2022-0847'])
        
        return config_cves
    
    def _get_resource_specific_cves(self, vulnerability: 'Vulnerability') -> List[str]:
        """Get resource-specific known CVEs."""
        resource_cves = []
        resource_type = vulnerability.resource_type.lower()
        
        # AWS service specific CVEs
        if 'aws_ec2' in resource_type:
            resource_cves.extend(['CVE-2023-4911', 'CVE-2022-0847'])
        elif 'aws_rds' in resource_type:
            resource_cves.extend(['CVE-2023-2283', 'CVE-2022-31160'])
        elif 'kubernetes' in resource_type:
            resource_cves.extend(['CVE-2024-3177', 'CVE-2023-3676'])
        
        return resource_cves
        
    def evaluate_condition(self, resource_data: Dict[str, Any], rule: Dict[str, Any]) -> bool:
        """
        Evaluate rule conditions against resource data.
        Supports both legacy format (attribute/value) and modern format (conditions array).
        """
        # Check for modern rule format with conditions array
        if 'conditions' in rule:
            return self.evaluate_modern_conditions(resource_data, rule['conditions'])
        
        # Legacy format
        attribute = rule.get('attribute')
        expected_value = rule.get('value')
        condition = rule.get('condition', 'equals')
        
        if attribute not in resource_data:
            # Handle missing attributes
            if condition == 'missing':
                return True
            return False
        
        actual_value = resource_data[attribute]
        
        # Handle different condition types
        if condition == 'equals' or condition is None:
            return actual_value == expected_value
        elif condition == 'missing':
            return False  # Attribute exists, so not missing
        elif condition == 'contains_cidr_0.0.0.0/0':
            # Special condition for security group rules
            if isinstance(actual_value, list):
                for item in actual_value:
                    if isinstance(item, dict) and '0.0.0.0/0' in str(item.get('cidr_blocks', [])):
                        return True
            return False
        elif condition == 'has_rules':
            # Check if security group has any rules
            if isinstance(actual_value, str) and actual_value == 'default':
                # Check if this default security group has ingress/egress rules
                ingress = resource_data.get('ingress', [])
                egress = resource_data.get('egress', [])
                return len(ingress) > 0 or len(egress) > 0
            return False
        
        return False
        
    def evaluate_modern_conditions(self, resource_data: Dict[str, Any], conditions: List[Dict[str, Any]]) -> bool:
        """
        Evaluate modern rule conditions with path-based access.
        All conditions must be true (AND logic).
        """
        import re
        
        for condition in conditions:
            path = condition.get('path', '')
            operator = condition.get('operator', 'equals')
            expected_value = condition.get('value')
            
            # Evaluate path to get actual value
            actual_value = self.get_value_by_path(resource_data, path)
            
            # Apply operator
            if operator == 'equals':
                if actual_value != expected_value:
                    return False
            elif operator == 'not_equals':
                if actual_value == expected_value:
                    return False
            elif operator == 'matches':
                if not isinstance(actual_value, str) or not re.search(expected_value, actual_value):
                    return False
            elif operator == 'not_empty':
                if not actual_value:
                    return False
            elif operator == 'not_exists':
                if actual_value is not None:
                    return False
            elif operator == 'exists':
                if actual_value is None:
                    return False
            elif operator == 'contains':
                if isinstance(actual_value, (list, str)):
                    if expected_value not in actual_value:
                        return False
                else:
                    return False
            elif operator == 'not_contains':
                if isinstance(actual_value, (list, str)):
                    if expected_value in actual_value:
                        return False
                else:
                    return False
            elif operator == 'greater_than':
                try:
                    if float(actual_value) <= float(expected_value):
                        return False
                except (ValueError, TypeError):
                    return False
            elif operator == 'less_than':
                try:
                    if float(actual_value) >= float(expected_value):
                        return False
                except (ValueError, TypeError):
                    return False
            elif operator == 'in':
                if actual_value not in expected_value:
                    return False
        
        return True
    
    def get_value_by_path(self, data: Dict[str, Any], path: str) -> Any:
        """
        Get value from nested dictionary using dot notation path.
        Supports array access with [*] wildcard and [index] notation.
        """
        if not path:
            return data
            
        parts = path.split('.')
        current = data
        
        for part in parts:
            if current is None:
                return None
                
            # Handle array access
            if '[' in part and ']' in part:
                array_name = part.split('[')[0]
                array_index = part.split('[')[1].split(']')[0]
                
                if array_name and array_name in current:
                    current = current[array_name]
                elif not array_name:
                    # Direct array access like [*] or [0]
                    pass
                else:
                    return None
                
                if not isinstance(current, list):
                    return None
                
                if array_index == '*':
                    # Wildcard - check all items
                    results = []
                    for item in current:
                        if isinstance(item, dict):
                            results.append(item)
                    current = results
                    if len(results) == 1:
                        current = results[0]
                    elif len(results) == 0:
                        return None
                else:
                    try:
                        idx = int(array_index)
                        if idx < len(current):
                            current = current[idx]
                        else:
                            return None
                    except ValueError:
                        return None
            else:
                # Regular dictionary access
                if isinstance(current, dict) and part in current:
                    current = current[part]
                elif isinstance(current, list):
                    # If current is a list and we're trying to access a property,
                    # check the first item (common for wildcard results)
                    if len(current) > 0 and isinstance(current[0], dict) and part in current[0]:
                        current = current[0][part]
                    else:
                        return None
                else:
                    return None
        
        return current
    
    def scan_resources(self, plan_data: Dict[str, Any], rules: List[Dict[str, Any]], 
                      ignored_findings: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Scan resources against enhanced security rules.
        
        Args:
            plan_data: Terraform plan JSON data
            rules: List of security rules
            ignored_findings: List of ignored findings
            
        Returns:
            Dictionary containing scan results
        """
        if ignored_findings is None:
            ignored_findings = []
            
        self.vulnerabilities_found = []
        self.ignored_count = 0
        
        resources = plan_data.get('planned_values', {}).get('root_module', {}).get('resources', [])
        
        # Also check resource_changes format
        resource_changes = plan_data.get('resource_changes', [])
        
        # Use resource_changes if planned_values is empty
        if not resources and resource_changes:
            for change in resource_changes:
                resource = {
                    'type': change.get('type'),
                    'name': change.get('name'),
                    'values': change.get('change', {}).get('after', {})
                }
                resources.append(resource)

        for rule in rules:
            # Get resource types from rule (support both old and new format)
            rule_resource_types = []
            if 'resource' in rule:
                # Old format
                rule_resource_types = [rule['resource']]
            elif 'resource_types' in rule:
                # New format
                rule_resource_types = rule['resource_types']
            
            for resource in resources:
                resource_type = resource.get('type')
                if resource_type in rule_resource_types:
                    resource_values = resource.get('values', {})
                    
                    if self.evaluate_condition(resource_values, rule):
                        vulnerability = self._create_vulnerability(rule, resource, resource_values)
                        
                        # Check if this finding should be ignored
                        if self._is_ignored(vulnerability, ignored_findings):
                            self.ignored_count += 1
                        else:
                            self.vulnerabilities_found.append(vulnerability)
        
        return self._generate_scan_report()
    
    def _create_vulnerability(self, rule: Dict[str, Any], resource: Dict[str, Any], 
                            resource_values: Dict[str, Any]) -> Vulnerability:
        """Create a vulnerability object from rule and resource data with CVE enhancement."""
        vulnerability = Vulnerability(
            id=rule.get('id', 'UNKNOWN'),
            title=rule.get('title', rule.get('description', 'Unknown vulnerability')),
            severity=SeverityLevel(rule.get('severity', 'MEDIUM')),
            severity_score=float(rule.get('severity_score', 5.0)),
            description=rule.get('description', ''),
            impact=rule.get('impact', 'Unknown impact'),
            remediation=rule.get('remediation', 'No remediation provided'),
            resource_type=resource.get('type', ''),
            resource_name=resource.get('name', ''),
            attribute=rule.get('attribute', ''),
            expected_value=rule.get('value'),
            actual_value=resource_values.get(rule.get('attribute')),
            cve_references=rule.get('cve_references', []),
            cis_controls=rule.get('cis_controls', []),
            tags=rule.get('tags', []),
            references=rule.get('references', [])
        )
        
        # 🚀 ENHANCE WITH MODERN CVE DATABASE!
        print(f"🔍 Enhancing {vulnerability.id} with modern CVEs...")
        enhanced_vulnerability = self.enhance_vulnerability_with_cves(vulnerability)
        
        return enhanced_vulnerability
    
    def _is_ignored(self, vulnerability: Vulnerability, ignored_findings: List[Dict[str, Any]]) -> bool:
        """Check if a vulnerability should be ignored."""
        for ignored in ignored_findings:
            if ignored.get('resource_name') == vulnerability.resource_name:
                if ignored.get('rule_id', vulnerability.id) == vulnerability.id:
                    return True
        return False
    
    def _generate_scan_report(self) -> Dict[str, Any]:
        """Generate comprehensive scan report."""
        # Sort vulnerabilities by severity score (highest first)
        sorted_vulns = sorted(self.vulnerabilities_found, 
                            key=lambda v: v.severity_score, reverse=True)
        
        # Count by severity
        severity_counts = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0,
            'INFO': 0
        }
        
        total_score = 0.0
        for vuln in sorted_vulns:
            severity_counts[vuln.severity.value] += 1
            total_score += vuln.severity_score
        
        # Calculate risk score (average of all vulnerability scores)
        risk_score = total_score / len(sorted_vulns) if sorted_vulns else 0.0
        
        return {
            'summary': {
                'total_vulnerabilities': len(sorted_vulns),
                'ignored_findings': self.ignored_count,
                'risk_score': round(risk_score, 2),
                'severity_distribution': severity_counts
            },
            'vulnerabilities': [vuln.to_dict() for vuln in sorted_vulns],
            'metadata': {
                'scan_timestamp': None,  # Will be set by caller
                'rules_applied': None,   # Will be set by caller
                'resources_scanned': None  # Will be set by caller
            }
        }
    
    def filter_by_severity(self, min_severity_score: float = 0.0, 
                          severity_levels: List[str] = None) -> List[Vulnerability]:
        """Filter vulnerabilities by severity criteria."""
        filtered = []
        
        for vuln in self.vulnerabilities_found:
            # Filter by score
            if vuln.severity_score < min_severity_score:
                continue
                
            # Filter by severity level
            if severity_levels and vuln.severity.value not in severity_levels:
                continue
                
            filtered.append(vuln)
        
        return filtered
    
    def filter_by_cve(self, cve_id: str) -> List[Vulnerability]:
        """Filter vulnerabilities that reference a specific CVE."""
        return [vuln for vuln in self.vulnerabilities_found 
                if cve_id in vuln.cve_references]
    
    def filter_by_tags(self, tags: List[str]) -> List[Vulnerability]:
        """Filter vulnerabilities by tags."""
        return [vuln for vuln in self.vulnerabilities_found 
                if any(tag in vuln.tags for tag in tags)]